#!/bin/bash

## Copyright (C) 2012 - 2019 ENCRYPTED SUPPORT LP <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

## https://forums.whonix.org/t/permission-hardening/8655
## https://forums.whonix.org/t/re-mount-home-and-other-with-noexec-and-nosuid-among-other-useful-mount-options-for-better-security/7707

#set -x
set -e

exit_code=0

echo_wrapper_ignore() {
   echo "run: $@"
   "$@" || true
}

echo_wrapper_audit() {
   echo "run: $@"
   "$@" || echo "ERROR: above command failed!" >&2
}

add_nosuid_statoverride_entry() {
  fso_to_process="${fso_without_trailing_slash}/"
  should_be_counter="$(find "$fso_to_process" -perm /u=s,g=s | wc -l)"
  counter_actual=0

  while read -r line; do
    true "line: $line"
    counter_actual="$(( counter_actual + 1 ))"

    arr=($line)

    file_name="${arr[0]}"
    existing_mode="${arr[1]}"
    owner="${arr[2]}"
    group="${arr[3]}"

    if [ "$file_name" = "" ]; then
      echo "ERROR: file_name is empty. line: '$line'" >&2
      continue
    fi
    if [ "$existing_mode" = "" ]; then
      echo "ERROR: existing_mode is empty. line: '$line'" >&2
      continue
    fi
    if [ "owner" = "" ]; then
      echo "ERROR: $owner is empty. line: '$line'" >&2
      continue
    fi
    if [ "$group" = "" ]; then
      echo "ERROR: $group is empty. line: '$line'" >&2
      continue
    fi

    ## -h file      True if file is a symbolic Link.
    ## -u file      True if file has its set-user-id bit set.
    ## -g file      True if file has its set-group-id bit set.

    if test -h "$file_name" ; then
      ## https://forums.whonix.org/t/kernel-hardening/7296/323
      true "skip symlink: $file_name"
      continue
    fi

    setuid=""
    setuid_output=""
    if test -u "$file_name" ; then
      setuid=true
      setuid_output="set-user-id"
    fi
    setguid=""
    setguid_output=""
    if test -g "$file_name"; then
      setguid=true
      setguid_output="set-group-id"
    fi

    if [ "$setuid" = "true" ] || [ "$setguid" = "true" ]; then
      string_length_of_existing_mode="${#existing_mode}"
      if [ "$string_length_of_existing_mode" = "4" ]; then
        new_mode="${existing_mode:1}"
      else
        new_mode="$existing_mode"
      fi

## Remove 'others' / 'group' execution ('chmod og-x /path/to/binary') rights for better usability?
## Make binaries such as 'su' fail closed rather than fail open if suid was removed from these?
## Are there suid or guid binaries which are still useful if suid / guid has been removed from these?
## https://forums.whonix.org/t/permission-hardening/8655/10
#       if [ "$new_mode" = "755" ]; then
#         new_mode=744
#       fi
#       if [ "$new_mode" = "754" ]; then
#         new_mode=744
#       fi
#       if [ "$new_mode" = "745" ]; then
#         new_mode=744
#       fi

      is_whitelisted=""
      for white_list_entry in $whitelist ; do
        if [ "$file_name" = "$white_list_entry" ]; then
          is_whitelisted="true"
          ## Stop looping through the whitelist.
          break
        fi
      done

      if [ "$is_whitelisted" = "true" ]; then
        echo "INFO: SKIP whitelisted - $setuid_output $setguid_output found - file_name: '$file_name' | existing_mode: '$existing_mode'"
        continue
      fi

      echo "INFO: $setuid_output $setguid_output found - file_name: '$file_name' | existing_mode: '$existing_mode' | new_mode: '$new_mode'"

      ## No need to check "dpkg-statoverride --list" for existing entries.
      ## If existing_mode was correct already, we would not have reached this point.
      ## Since existing_mode is incorrect, remove from dpkg-statoverride and re-add.
      echo_wrapper_ignore dpkg-statoverride --remove "$file_name"
      echo_wrapper_audit dpkg-statoverride --add --update "$owner" "$group" "$new_mode" "$file_name"
    fi

  ## /lib will hit ARG_MAX.
  ## That was before using '-perm /u=s,g=s'.
  ## https://forums.whonix.org/t/kernel-hardening/7296/326
  done < <( find "$fso_to_process" -perm /u=s,g=s -print0 | xargs -I{} -0 stat -c "%n %a %U %G" {} )

  ## Sanity test.
  if [ ! "$should_be_counter" = "$counter_actual" ]; then
    echo "INFO: fso_to_process: '$fso_to_process' | counter_actual   : '$counter_actual'"
    echo "INFO: fso_to_process: '$fso_to_process' | should_be_counter: '$should_be_counter'"
    exit_code=202
    echo "ERROR: counter does not check out." >&2
  fi
}

set_file_perms() {
  echo "INFO: parsing config_file: '$config_file'"
  while read -r line; do
    if [ "$line" = "" ]; then
      continue
    fi

    if [[ "$line" =~ ^# ]]; then
      continue
    fi

    if [[ "$line" =~ [0-9a-zA-Z/] ]]; then
      true OK
    else
      exit_code=200
      echo "ERROR: cannot parse line with invalid character: $line" >&2
      continue
    fi

    if ! read -r fso mode_from_config owner group capability <<< "$line" ; then
      exit_code=201
      echo "ERROR: cannot parse line: $line" >&2
      continue
    fi

    fso_without_trailing_slash="${fso%/}"

    if [ "$mode_from_config" = "whitelist" ]; then
      whitelist+="$fso_without_trailing_slash "
      continue
    fi

    if ! [ -e "$fso" ]; then
      echo "INFO: fso: '$fso' - does not exist. This is likely normal."
      continue
    fi

    ## Use dpkg-statoverride  so permissions are not reset during upgrades.

    nosuid=""
    if [ "$mode_from_config" = "nosuid" ]; then
      nosuid="true"

      ## If mode_from_config is "nosuid" the config does not set owner and
      ## group. Therefore do not enforce owner/group check.

      add_nosuid_statoverride_entry
    else
      string_length_of_mode_from_config="${#mode_from_config}"
      if [ "$string_length_of_mode_from_config" -gt "4" ]; then
         echo "ERROR: Mode '$mode_from_config' is invalid!" >&2
         continue
      fi
      if [ "$string_length_of_mode_from_config" -lt "3" ]; then
         echo "ERROR: Mode '$mode_from_config' is invalid!" >&2
         continue
      fi

      if ! getent passwd | grep -q "^${owner}:"; then
         echo "ERROR: User '$owner' does not exist!" >&2
         continue
      fi

      if ! getent group | grep -q "^${group}:"; then
         echo "ERROR: Group '$group' does not exist!" >&2
         continue
      fi

      mode_for_grep="$mode_from_config"
      first_character_of_mode_from_config="${mode_from_config::1}"
      if [ "$first_character_of_mode_from_config" = "0" ]; then
         ## Remove leading '0'.
         mode_for_grep="${mode_from_config:1}"
      fi

      ## Check there is an entry for the fso.
      ##
      ## example: dpkg-statoverride --list | grep /home
      ## output:
      ## root root 755 /home
      ##
      ## dpkg-statoverride does not show leading '0'.
      if dpkg-statoverride --list | grep -q "$fso_without_trailing_slash"; then
        ## There is an fso entry. Check if owner/group/mode match.
        if dpkg-statoverride --list | grep -q "$owner $group $mode_for_grep $fso_without_trailing_slash"; then
          ## The owner/group/mode matches. No further action required.
          true OK
        else
          ## The owner/group/mode do not match, therefore remove and re-add the entry to update it.
          ## fso_without_trailing_slash instead of fso to prevent
          ## "dpkg-statoverride: warning: stripping trailing /"
          echo_wrapper_audit dpkg-statoverride --remove "$fso_without_trailing_slash"
          echo_wrapper_audit dpkg-statoverride --add --update "$owner" "$group" "$mode_from_config" "$fso_without_trailing_slash"
        fi
      else
        ## There is no fso entry. Therefore add one.
        echo_wrapper_audit dpkg-statoverride --add --update "$owner" "$group" "$mode_from_config" "$fso_without_trailing_slash"
      fi
    fi

    if [ "$capability" = "" ]; then
      continue
    fi

    if [ "$capability" = "none" ]; then
      echo_wrapper_audit setcap -r "$fso"
    else
      if ! capsh --print | grep "Bounding set" | grep -q "$capability"; then
         echo "ERROR: Capability '$capability' does not exist!" >&2
         continue
      fi

      echo_wrapper_audit setcap "${capability}+ep" "$fso"
    fi
  done < "$config_file"
}

parse_config_folder() {
  shopt -s nullglob
  for config_file in /etc/permission-hardening.d/*.conf /usr/local/etc/permission-hardening.d/*.conf; do
    set_file_perms
  done
}

parse_config_folder

if [ ! "$exit_code" = "0" ]; then
   echo "ERROR: Will exist with non-zero exit code: '$exit_code'" >&2
fi

exit "$exit_code"
